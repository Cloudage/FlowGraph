/*
 * MIT License
 *
 * Copyright (c) 2025 ExpressionKit Contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * NOTE: This code is primarily generated by AI (GitHub Copilot and Claude Sonnet 4)
 * with human guidance and review. The implementation follows modern C++ best
 * practices and provides a clean, interface-based expression evaluation system.
 */

/**
 * @file ExpressionKit.hpp
 * @brief A lightweight, interface-driven expression parser and evaluator for C++
 * @version 1.0.0
 * @date 2025-07-24
 *
 * ExpressionKit provides a clean and extensible way to parse and evaluate mathematical
 * and logical expressions. Key features include:
 *
 * - Interface-based variable and function access through Environment abstraction
 * - Pre-parsed AST support for efficient repeated evaluation
 * - Support for numbers, booleans, variables, and function calls
 * - Comprehensive operator support (arithmetic, comparison, logical)
 * - Type-safe value system with automatic conversions
 * - Exception-based error handling
 *
 * The library is designed to be embedded in larger applications where expressions
 * need to be evaluated against dynamic data sources.
 */

#ifndef EXPRESSION_KIT_HPP
#define EXPRESSION_KIT_HPP

#include <string>
#include <memory>
#include <stdexcept>
#include <vector>
#include <iostream>
#include <cmath>
#include <algorithm>

namespace ExpressionKit {

    // Forward declarations for internal use
    class ASTNode;
    class Expression;
    using ASTNodePtr = std::shared_ptr<ASTNode>;

    /**
     * @brief Token types for syntax highlighting and analysis
     *
     * This enumeration defines all possible token types that can be identified
     * during expression parsing, useful for syntax highlighting and other
     * analysis features.
     */
    enum class TokenType {
        NUMBER,       // Numeric literals: 42, 3.14, -2.5
        BOOLEAN,      // Boolean literals: true, false
        STRING,       // String literals: "hello", "world"
        IDENTIFIER,   // Variables and function names: x, pos.x, sqrt
        OPERATOR,     // Operators: +, -, *, /, ==, !=, &&, ||, etc.
        PARENTHESIS,  // Parentheses: (, )
        COMMA,        // Function argument separator: ,
        WHITESPACE,   // Spaces, tabs (optional for highlighting)
        UNKNOWN       // Unrecognized tokens
    };

    /**
     * @brief Token structure for syntax highlighting and analysis
     *
     * Contains information about a single token identified during parsing,
     * including its type, position in the source text, and the actual text.
     */
    struct Token {
        TokenType type;        // Type of the token
        size_t start;          // Starting position in source text
        size_t length;         // Length of the token
        std::string text;      // The actual token text

        Token(TokenType t, size_t s, size_t l, const std::string& txt)
            : type(t), start(s), length(l), text(txt) {}
    };

    /**
     * @brief Exception type for expression parsing and evaluation errors
     */
    class ExprException final : public std::runtime_error {
    public:
        explicit ExprException(const std::string& msg) : std::runtime_error(msg) {}
    };

    /**
     * @brief Simplified Value type that directly uses the C bridge structure
     * 
     * This eliminates duplication by using the same structure as the C interface
     * while providing C++ convenience methods and operators.
     */
    struct Value {
        enum Type : int { NUMBER = 0, BOOLEAN = 1, STRING = 2 } type;
        
        union Data {
            double number;
            bool boolean;
            // Note: string is stored separately due to union limitations
            
            Data() : number(0.0) {}
            explicit Data(double n) : number(n) {}
            explicit Data(bool b) : boolean(b) {}
        } data;
        
        // String data stored separately from union
        std::string stringValue;

        // Constructors
        Value() : type(NUMBER) { data.number = 0.0; }
        Value(double n) : type(NUMBER) { data.number = n; }
        Value(float n) : type(NUMBER) { data.number = static_cast<double>(n); }
        Value(int n) : type(NUMBER) { data.number = static_cast<double>(n); }
        Value(bool b) : type(BOOLEAN) { data.boolean = b; }
        Value(const std::string& s) : type(STRING), stringValue(s) {}
        Value(const char* s) : type(STRING), stringValue(s) {}

        // Type checking
        bool isNumber() const { return type == NUMBER; }
        bool isBoolean() const { return type == BOOLEAN; }
        bool isString() const { return type == STRING; }

        // Safe value extraction
        double asNumber() const {
            if (isNumber()) return data.number;
            if (isString()) {
                // Try to convert string to number
                try {
                    size_t pos;
                    double result = std::stod(stringValue, &pos);
                    // Check if entire string was consumed
                    if (pos == stringValue.length()) return result;
                } catch (...) {
                    // Fall through to throw exception
                }
                throw ExprException("无法将字符串 '" + stringValue + "' 转换为数值");
            }
            if (isBoolean()) return data.boolean ? 1.0 : 0.0;
            throw ExprException("类型错误：期望数值");
        }

        bool asBoolean() const {
            if (isBoolean()) return data.boolean;
            if (isNumber()) return data.number != 0.0;
            if (isString()) {
                // Convert string to boolean: non-empty strings are true
                return !stringValue.empty();
            }
            throw ExprException("类型错误：期望布尔值");
        }
        
        std::string asString() const {
            if (isString()) return stringValue;
            if (isNumber()) return std::to_string(data.number);
            if (isBoolean()) return data.boolean ? "true" : "false";
            throw ExprException("类型错误：期望字符串");
        }

        // String conversion
        std::string toString() const {
            return asString();
        }

        // Equality
        bool operator==(const Value& other) const {
            if (type == other.type) {
                if (isNumber()) return data.number == other.data.number;
                if (isBoolean()) return data.boolean == other.data.boolean;
                if (isString()) return stringValue == other.stringValue;
            }
            return false;
        }

        bool operator!=(const Value& other) const {
            return !(*this == other);
        }
    };

    /**
     * @brief Environment interface for variable access and function calls
     *
     * Implement this interface to provide custom variable storage and function
     * implementations. The environment is responsible for handling variable reads,
     * optional variable writes, and function calls during expression evaluation.
     *
     * @note The integrating application is responsible for managing the environment's
     *       lifetime. ExpressionKit stores only a raw pointer and does not take ownership.
     */
    class IEnvironment {
        protected: IEnvironment() = default;

    public:
        virtual ~IEnvironment() = default;

        /**
         * @brief Get a variable value by name
         * @param name Variable name (supports dot notation like "pos.x")
         * @return The variable value
         * @throws ExprException if the variable is not found
         */
        virtual Value Get(const std::string& name) = 0;

        /**
         * @brief Call a function with given arguments
         * @param name Function name
         * @param args Function arguments
         * @return Function result
         * @throws ExprException if the function is not found or arguments are invalid
         */
        virtual Value Call(const std::string& name, const std::vector<Value>& args) = 0;
    };

    /**
     * @brief Abstract base class for all AST (Abstract Syntax Tree) nodes
     *
     * This is the foundation of the expression evaluation system. Every element
     * in an expression (numbers, variables, operators, functions) is represented
     * as an AST node that can be evaluated against an environment.
     *
     * @note This is an internal implementation detail. Users typically work
     *       with compiled expressions through the ExpressionKit interface.
     */
    class ASTNode {
    public:
        virtual ~ASTNode() = default;

        /**
         * @brief Evaluate this node and return its value
         * @param environment Environment for variable and function resolution (can be null for constants)
         * @return The computed value of this node
         * @throws ExprException If evaluation fails
         */
        virtual Value evaluate(IEnvironment* environment) const = 0;
    };

    /**
     * @brief AST node representing a numeric literal
     *
     * This node holds a constant numeric value and returns it during evaluation.
     * Examples: 42, 3.14, -2.5
     */
    class NumberNode final : public ASTNode {
        double value;
    public:
        explicit NumberNode(const double v) : value(v) {}
        Value evaluate(IEnvironment*) const override {
            return Value(value);
        }
    };

    /**
     * @brief AST node representing a boolean literal
     *
     * This node holds a constant boolean value and returns it during evaluation.
     * Examples: true, false
     */
    class BooleanNode final : public ASTNode {
        bool value;
    public:
        explicit BooleanNode(const bool v) : value(v) {}
        Value evaluate(IEnvironment*) const override {
            return Value(value);
        }
    };

    /**
     * @brief AST node representing a string literal
     *
     * This node holds a constant string value and returns it during evaluation.
     * Examples: "hello", "world", "Hello, \"World\"!"
     */
    class StringNode final : public ASTNode {
        std::string value;
    public:
        explicit StringNode(const std::string& v) : value(v) {}
        Value evaluate(IEnvironment*) const override {
            return Value(value);
        }
    };

    /**
     * @brief AST node representing a variable reference
     *
     * This node stores a variable name and delegates to the IEnvironment during
     * evaluation to resolve the variable's current value.
     * Examples: x, pos.x, player_health
     */
    class VariableNode final : public ASTNode {
        std::string name;
    public:
        explicit VariableNode(const std::string& n) : name(n) {}
        Value evaluate(IEnvironment* environment) const override {
            if (!environment) throw ExprException("变量访问需要 IEnvironment");
            return environment->Get(name);
        }
    };

    /**
     * @brief Call standard mathematical functions
     * 
     * This function handles built-in mathematical functions:
     * - min(a, b): Returns the smaller of two numbers
     * - max(a, b): Returns the larger of two numbers
     * - sqrt(x): Returns the square root of x
     * - sin(x): Returns the sine of x (in radians)
     * - cos(x): Returns the cosine of x (in radians)
     * - tan(x): Returns the tangent of x (in radians)
     * - abs(x): Returns the absolute value of x
     * - pow(x, y): Returns x raised to the power of y
     * - log(x): Returns the natural logarithm of x
     * - exp(x): Returns e raised to the power of x
     * - floor(x): Returns the largest integer less than or equal to x
     * - ceil(x): Returns the smallest integer greater than or equal to x
     * - round(x): Returns x rounded to the nearest integer
     */
    inline bool CallStandardFunctions(const std::string& functionName,
                              const std::vector<Value>& args,
                              Value& outResult) {
        try {
            // Two-argument functions
            if (functionName == "min" && args.size() == 2) {
                if (!args[0].isNumber() || !args[1].isNumber()) return false;
                outResult = Value(std::min(args[0].asNumber(), args[1].asNumber()));
                return true;
            }
            if (functionName == "max" && args.size() == 2) {
                if (!args[0].isNumber() || !args[1].isNumber()) return false;
                outResult = Value(std::max(args[0].asNumber(), args[1].asNumber()));
                return true;
            }
            if (functionName == "pow" && args.size() == 2) {
                if (!args[0].isNumber() || !args[1].isNumber()) return false;
                outResult = Value(std::pow(args[0].asNumber(), args[1].asNumber()));
                return true;
            }

            // Single-argument functions
            if (args.size() == 1 && args[0].isNumber()) {
                double x = args[0].asNumber();

                if (functionName == "sqrt") {
                    if (x < 0) return false; // Domain error
                    outResult = Value(std::sqrt(x));
                    return true;
                }
                if (functionName == "sin") {
                    outResult = Value(std::sin(x));
                    return true;
                }
                if (functionName == "cos") {
                    outResult = Value(std::cos(x));
                    return true;
                }
                if (functionName == "tan") {
                    outResult = Value(std::tan(x));
                    return true;
                }
                if (functionName == "abs") {
                    outResult = Value(std::abs(x));
                    return true;
                }
                if (functionName == "log") {
                    if (x <= 0) return false; // Domain error
                    outResult = Value(std::log(x));
                    return true;
                }
                if (functionName == "exp") {
                    outResult = Value(std::exp(x));
                    return true;
                }
                if (functionName == "floor") {
                    outResult = Value(std::floor(x));
                    return true;
                }
                if (functionName == "ceil") {
                    outResult = Value(std::ceil(x));
                    return true;
                }
                if (functionName == "round") {
                    outResult = Value(std::round(x));
                    return true;
                }
            }

            return false; // Function not found or invalid arguments
        } catch (...) {
            return false; // Error occurred
        }
    }

    /**
     * @brief Enumeration of all supported operators
     *
     * This enum defines all arithmetic, comparison, and logical operators
     * supported by the expression system. Operators are grouped by category
     * for easier understanding and implementation.
     */
    enum class OperatorType {
        ADD, SUB, MUL, DIV,           // 算术运算符: +, -, *, /
        EQ, NE, GT, LT, GE, LE,       // 比较运算符: ==, !=, >, <, >=, <=
        IN,                           // 包含运算符: in
        AND, OR, XOR, NOT             // 逻辑运算符: &&, ||, xor, !
    };

    /**
     * @brief AST node representing binary operations (operations with two operands)
     *
     * This node handles all binary operators including arithmetic, comparison,
     * and logical operations. It evaluates both operands and applies the
     * specified operator according to type compatibility rules.
     *
     * Supported operations:
     * - Arithmetic: 2 + 3, 5 * 4, 10 / 2, 7 - 1
     * - Comparison: x == 5, age >= 18, score != 0
     * - Logical: a && b, x || y, p xor q
     */
    class BinaryOpNode final : public ASTNode {
        ASTNodePtr left, right;
        OperatorType op;
    public:
        BinaryOpNode(ASTNodePtr l, const OperatorType o, ASTNodePtr r)
            : left(std::move(l)), right(std::move(r)), op(o) {}

        Value evaluate(IEnvironment* environment) const override {
            const Value lhs = left->evaluate(environment);
            const Value rhs = right->evaluate(environment);

            // 字符串运算
            if (lhs.isString() || rhs.isString()) {
                switch (op) {
                    case OperatorType::ADD: {
                        // 字符串连接：将两个操作数都转换为字符串
                        return Value(lhs.asString() + rhs.asString());
                    }
                    case OperatorType::EQ: {
                        // 字符串相等比较
                        if (lhs.isString() && rhs.isString()) {
                            return Value(lhs.asString() == rhs.asString());
                        }
                        // 类型不同时为不相等
                        return Value(false);
                    }
                    case OperatorType::NE: {
                        // 字符串不等比较
                        if (lhs.isString() && rhs.isString()) {
                            return Value(lhs.asString() != rhs.asString());
                        }
                        // 类型不同时为不相等
                        return Value(true);
                    }
                    case OperatorType::GT:
                    case OperatorType::LT:
                    case OperatorType::GE:
                    case OperatorType::LE: {
                        // 字符串比较：两个操作数都必须是字符串
                        if (lhs.isString() && rhs.isString()) {
                            const std::string& a = lhs.asString();
                            const std::string& b = rhs.asString();
                            switch (op) {
                                case OperatorType::GT: return Value(a > b);
                                case OperatorType::LT: return Value(a < b);
                                case OperatorType::GE: return Value(a >= b);
                                case OperatorType::LE: return Value(a <= b);
                                default: break;
                            }
                        }
                        throw ExprException("字符串比较运算符需要两个字符串操作数");
                    }
                    case OperatorType::IN: {
                        // 字符串包含检查：检查左操作数是否包含在右操作数中
                        if (lhs.isString() && rhs.isString()) {
                            const std::string& needle = lhs.asString();
                            const std::string& haystack = rhs.asString();
                            return Value(haystack.find(needle) != std::string::npos);
                        }
                        throw ExprException("in 运算符需要两个字符串操作数");
                    }
                    default:
                        throw ExprException("不支持的字符串运算符");
                }
            }

            // 数值运算
            if (lhs.isNumber() && rhs.isNumber()) {
                const double a = lhs.asNumber();
                const double b = rhs.asNumber();
                switch (op) {
                    case OperatorType::ADD: return Value(a + b);
                    case OperatorType::SUB: return Value(a - b);
                    case OperatorType::MUL: return Value(a * b);
                    case OperatorType::DIV:
                        if (b == 0) throw ExprException("除零错误");
                        return Value(a / b);
                    case OperatorType::GT: return Value(a > b);
                    case OperatorType::LT: return Value(a < b);
                    case OperatorType::GE: return Value(a >= b);
                    case OperatorType::LE: return Value(a <= b);
                    case OperatorType::EQ: return Value(a == b);
                    case OperatorType::NE: return Value(a != b);
                    default:
                        throw ExprException("不支持的数值运算符");
                }
            }
            // 布尔运算
            else if (lhs.isBoolean() && rhs.isBoolean()) {
                const bool a = lhs.asBoolean();
                const bool b = rhs.asBoolean();
                switch (op) {
                    case OperatorType::AND: return Value(a && b);
                    case OperatorType::OR: return Value(a || b);
                    case OperatorType::XOR: return Value(a != b); // XOR 是异或
                    case OperatorType::EQ: return Value(a == b);
                    case OperatorType::NE: return Value(a != b);
                    default:
                        throw ExprException("不支持的布尔运算符");
                }
            }

            throw ExprException("不支持的操作数类型");
        }
    };

    /**
     * @brief AST node representing unary operations (operations with one operand)
     *
     * This node handles unary operators that operate on a single value:
     * - Logical NOT: !condition, not flag
     * - Arithmetic negation: -number, -expression
     *
     * Examples: !true, -42, -(x + y), not visible
     */
    class UnaryOpNode final : public ASTNode {
        ASTNodePtr operand;
        OperatorType op;
    public:
        UnaryOpNode(const OperatorType o, ASTNodePtr operand)
            : operand(std::move(operand)), op(o) {}

        Value evaluate(IEnvironment* environment) const override {
            const Value val = operand->evaluate(environment);

            switch (op) {
                case OperatorType::NOT:
                    if (!val.isBoolean()) throw ExprException("NOT 运算符只能用于布尔值");
                    return Value(!val.asBoolean());
                case OperatorType::SUB: // 负号
                    if (!val.isNumber()) throw ExprException("负号只能用于数值");
                    return Value(-val.asNumber());
                default:
                    throw ExprException("不支持的一元运算符");
            }
        }
    };

    /**
     * @brief AST node representing function calls
     *
     * This node stores a function name and a list of argument expressions.
     * During evaluation, it evaluates all arguments and delegates to the
     * IEnvironment to perform the actual function Call.
     *
     * Examples: max(a, b), sqrt(x), distance(x1, y1, x2, y2)
     */
    class FunctionCallNode final : public ASTNode {
        std::string name;
        std::vector<ASTNodePtr> args;
    public:
        FunctionCallNode(const std::string& n, std::vector<ASTNodePtr> a)
            : name(n), args(std::move(a)) {}

        Value evaluate(IEnvironment* environment) const override {
            std::vector<Value> evaluatedArgs;
            for (const auto& arg : args) {
                evaluatedArgs.push_back(arg->evaluate(environment));
            }
            
            // First try standard mathematical functions (works without environment)
            Value standardResult;
            if (CallStandardFunctions(name, evaluatedArgs, standardResult)) {
                return standardResult;
            }
            
            // If not a standard function, require environment
            if (!environment) throw ExprException("函数调用需要 IEnvironment");
            return environment->Call(name, evaluatedArgs);
        }
    };

    /**
     * @brief Recursive descent parser for expression strings
     *
     * This class implements a complete expression parser using the recursive
     * descent parsing technique. It supports operator precedence, associativity,
     * and proper error reporting.
     *
     * Grammar (in order of precedence, highest to lowest):
     * - Primary: numbers, booleans, variables, function calls, parentheses
     * - Unary: !, not, - (unary minus)
     * - Multiplicative: *, /
     * - Additive: +, -
     * - Relational: <, >, <=, >=
     * - Equality: ==, !=
     * - Logical XOR: xor
     * - Logical AND: &&, and
     * - Logical OR: ||, or
     *
     * The parser is designed to be used once per expression string and
     * produces an AST that can be evaluated multiple times efficiently.
     */
    class Parser {
        std::string expr;
        size_t pos = 0;
        std::vector<Token>* tokens = nullptr;  // Optional token collection

        void addToken(TokenType type, size_t start, size_t length, const std::string& text) {
            if (tokens) {
                tokens->emplace_back(type, start, length, text);
            }
        }

        void addToken(TokenType type, size_t start, size_t length) {
            if (tokens && start + length <= expr.length()) {
                addToken(type, start, length, expr.substr(start, length));
            }
        }

        void skipWhitespace() {
            size_t start = pos;
            while (pos < expr.size() && std::isspace(expr[pos])) ++pos;
            if (tokens && pos > start) {
                addToken(TokenType::WHITESPACE, start, pos - start);
            }
        }

        bool match(const std::string& str) {
            skipWhitespace();
            if (pos + str.length() <= expr.size() &&
                expr.substr(pos, str.length()) == str) {
                addToken(TokenType::OPERATOR, pos, str.length(), str);
                pos += str.length();
                return true;
            }
            return false;
        }

        bool match(const char c) {
            skipWhitespace();
            if (pos < expr.size() && expr[pos] == c) {
                TokenType type = (c == '(' || c == ')') ? TokenType::PARENTHESIS :
                                (c == ',') ? TokenType::COMMA : TokenType::OPERATOR;
                addToken(type, pos, 1, std::string(1, c));
                ++pos;
                return true;
            }
            return false;
        }

        char peek() {
            skipWhitespace();
            if (pos >= expr.size()) return '\0';
            return expr[pos];
        }

        std::string peekString(const size_t len) {
            skipWhitespace();
            if (pos + len > expr.size()) return "";
            return expr.substr(pos, len);
        }

        char consume() {
            skipWhitespace();
            if (pos >= expr.size()) throw ExprException("意外的表达式结尾");
            char c = expr[pos];
            addToken(TokenType::OPERATOR, pos, 1, std::string(1, c));
            return expr[pos++];
        }

        // 解析逻辑表达式（最低优先级）
        ASTNodePtr parseOrExpression() {
            auto left = parseAndExpression();
            while (match("||") || match("or")) {
                auto right = parseAndExpression();
                left = std::make_shared<BinaryOpNode>(left, OperatorType::OR, right);
            }
            return left;
        }

        // 解析与表达式
        ASTNodePtr parseAndExpression() {
            auto left = parseXorExpression();
            while (match("&&") || match("and")) {
                auto right = parseXorExpression();
                left = std::make_shared<BinaryOpNode>(left, OperatorType::AND, right);
            }
            return left;
        }

        // 解析异或表达式
        ASTNodePtr parseXorExpression() {
            auto left = parseEqualityExpression();
            while (match("xor")) {
                auto right = parseEqualityExpression();
                left = std::make_shared<BinaryOpNode>(left, OperatorType::XOR, right);
            }
            return left;
        }

        // 解析相等性表达式
        ASTNodePtr parseEqualityExpression() {
            auto left = parseRelationalExpression();
            while (true) {
                if (match("==")) {
                    auto right = parseRelationalExpression();
                    left = std::make_shared<BinaryOpNode>(left, OperatorType::EQ, right);
                } else if (match("!=")) {
                    auto right = parseRelationalExpression();
                    left = std::make_shared<BinaryOpNode>(left, OperatorType::NE, right);
                } else {
                    break;
                }
            }
            return left;
        }

        // 解析关系表达式
        ASTNodePtr parseRelationalExpression() {
            auto left = parseAdditiveExpression();
            while (true) {
                if (match(">=")) {
                    auto right = parseAdditiveExpression();
                    left = std::make_shared<BinaryOpNode>(left, OperatorType::GE, right);
                } else if (match("<=")) {
                    auto right = parseAdditiveExpression();
                    left = std::make_shared<BinaryOpNode>(left, OperatorType::LE, right);
                } else if (match(">")) {
                    auto right = parseAdditiveExpression();
                    left = std::make_shared<BinaryOpNode>(left, OperatorType::GT, right);
                } else if (match("<")) {
                    auto right = parseAdditiveExpression();
                    left = std::make_shared<BinaryOpNode>(left, OperatorType::LT, right);
                } else if (match("in")) {
                    auto right = parseAdditiveExpression();
                    left = std::make_shared<BinaryOpNode>(left, OperatorType::IN, right);
                } else {
                    break;
                }
            }
            return left;
        }

        // 解析加减表达式
        ASTNodePtr parseAdditiveExpression() {
            auto left = parseMultiplicativeExpression();
            while (peek() == '+' || peek() == '-') {
                const char op = consume();
                auto right = parseMultiplicativeExpression();
                OperatorType opType = (op == '+') ? OperatorType::ADD : OperatorType::SUB;
                left = std::make_shared<BinaryOpNode>(left, opType, right);
            }
            return left;
        }

        // 解析乘除表达式
        ASTNodePtr parseMultiplicativeExpression() {
            auto left = parseUnaryExpression();
            while (peek() == '*' || peek() == '/') {
                const char op = consume();
                auto right = parseUnaryExpression();
                OperatorType opType = (op == '*') ? OperatorType::MUL : OperatorType::DIV;
                left = std::make_shared<BinaryOpNode>(left, opType, right);
            }
            return left;
        }

        // 解析一元表达式
        ASTNodePtr parseUnaryExpression() {
            if (match("!") || match("not")) {
                auto operand = parseUnaryExpression();
                return std::make_shared<UnaryOpNode>(OperatorType::NOT, operand);
            }

            if (match("-")) {
                auto operand = parseUnaryExpression();
                return std::make_shared<UnaryOpNode>(OperatorType::SUB, operand);
            }

            return parsePrimaryExpression();
        }

        // 解析基本表达式
        ASTNodePtr parsePrimaryExpression() {
            if (match('(')) {
                auto expr = parseOrExpression();
                if (!match(')')) throw ExprException("缺少右括号");
                return expr;
            }

            if (std::isdigit(peek()) || peek() == '.') {
                size_t start = pos;
                std::string num;
                while (pos < expr.size() && (std::isdigit(expr[pos]) || expr[pos] == '.')) {
                    num += expr[pos++];
                }
                addToken(TokenType::NUMBER, start, pos - start, num);
                return std::make_shared<NumberNode>(std::stod(num));
            }

            // 解析字符串字面量
            if (peek() == '"') {
                size_t start = pos;
                ++pos; // 跳过开始的引号
                std::string str;
                
                while (pos < expr.size() && expr[pos] != '"') {
                    if (expr[pos] == '\\' && pos + 1 < expr.size()) {
                        // 处理转义序列
                        ++pos; // 跳过反斜杠
                        switch (expr[pos]) {
                            case 'n': str += '\n'; break;
                            case 't': str += '\t'; break;
                            case 'r': str += '\r'; break;
                            case '\\': str += '\\'; break;
                            case '"': str += '"'; break;
                            default:
                                // 未知转义序列，保留原字符
                                str += '\\';
                                str += expr[pos];
                                break;
                        }
                        ++pos;
                    } else {
                        str += expr[pos++];
                    }
                }
                
                if (pos >= expr.size()) {
                    throw ExprException("未结束的字符串字面量");
                }
                
                ++pos; // 跳过结束的引号
                addToken(TokenType::STRING, start, pos - start, "\"" + str + "\"");
                return std::make_shared<StringNode>(str);
            }

            if (std::isalpha(peek())) {
                size_t start = pos;
                std::string ident;
                while (pos < expr.size() && (std::isalnum(expr[pos]) || expr[pos] == '.' || expr[pos] == '_')) {
                    ident += expr[pos++];
                }

                if (match('(')) {
                    std::vector<ASTNodePtr> args;
                    if (!match(')')) {
                        do {
                            args.push_back(parseOrExpression());
                        } while (match(','));
                        if (!match(')')) throw ExprException("函数调用缺少右括号");
                    }
                    addToken(TokenType::IDENTIFIER, start, ident.length(), ident);
                    return std::make_shared<FunctionCallNode>(ident, args);
                }

                if (ident == "true") {
                    addToken(TokenType::BOOLEAN, start, ident.length(), ident);
                    return std::make_shared<BooleanNode>(true);
                }
                if (ident == "false") {
                    addToken(TokenType::BOOLEAN, start, ident.length(), ident);
                    return std::make_shared<BooleanNode>(false);
                }

                addToken(TokenType::IDENTIFIER, start, ident.length(), ident);
                return std::make_shared<VariableNode>(ident);
            }

            throw ExprException("无法识别的表达式");
        }

    public:
        explicit Parser(const std::string& expression) : expr(expression) {}
        explicit Parser(const std::string& expression, std::vector<Token>* tokenVector) 
            : expr(expression), tokens(tokenVector) {}

        ASTNodePtr parse() {
            pos = 0;
            auto result = parseOrExpression();
            skipWhitespace();
            if (pos < expr.size()) throw ExprException("表达式解析不完整");
            return result;
        }
    };

    /**
     * @brief Main expression toolkit class for parsing and evaluating expressions
     *
     * Expression provides a complete expression evaluation system with support for:
     * - Arithmetic operations (+, -, *, /)
     * - Comparison operations (==, !=, <, >, <=, >=)
     * - Logical operations (&&, ||, !, xor)
     * - Variables and functions via Environment interface
     * - Expression compilation and caching for better performance
     *
     * Usage examples:
     * @code
     * Expression exprtk;
     *
     * // Simple evaluation without variables
     * auto result = exprtk.Eval("2 + 3 * 4"); // Returns 14.0
     *
     * // With environment for variables and functions
     * MyEnvironment environment;
     * exprtk.SetEnvironment(&environment);
     * auto result2 = exprtk.Eval("x + sqrt(y)");
     *
     * // Compile once, execute multiple times
     * auto compiled = exprtk.Compile("health > maxHealth * 0.5");
     * for (int frame = 0; frame < 100; ++frame) {
     *     auto alive = exprtk.Execute(compiled);
     *     // ... game logic
     * }
     * @endcode
     *
     * @note The Expression instance does not own the Environment object. The caller is
     *       responsible for ensuring the Environment remains valid during expression
     *       evaluation.
     */
    class Expression {
    public:
        /**
         * @brief Evaluate an expression string directly
         * @param expression The expression string to evaluate
         * @param environment Optional environment for variable and function resolution
         * @return The evaluation result
         * @throws ExprException If parsing fails or evaluation encounters an error
         *
         * This method parses and evaluates the expression in one Call. For
         * expressions that will be evaluated multiple times, consider using
         * Compile() and Execute() for better performance.
         *
         * Supported syntax:
         * - Numbers: 42, 3.14, -2.5
         * - Booleans: true, false
         * - Arithmetic: +, -, *, /
         * - Comparison: ==, !=, <, >, <=, >=
         * - Logical: &&, ||, !, and, or, not, xor
         * - Parentheses for grouping: (expr)
         * - Variables: x, pos.x, player_health
         * - Functions: max(a, b), sqrt(x)
         */
        static Value Eval(const std::string& expression, IEnvironment* environment = nullptr) {
            return Parse(expression)->evaluate(environment);
        }

        /**
         * @brief Evaluate an expression string directly with token collection
         * @param expression The expression string to evaluate
         * @param environment Optional environment for variable and function resolution
         * @param tokens Optional vector to collect tokens for syntax highlighting
         * @return The evaluation result
         * @throws ExprException If parsing fails or evaluation encounters an error
         *
         * This method parses and evaluates the expression while optionally collecting
         * tokens that can be used for syntax highlighting or other analysis.
         */
        static Value Eval(const std::string& expression, IEnvironment* environment, std::vector<Token>* tokens) {
            return Parse(expression, tokens)->evaluate(environment);
        }

        /**
         * @brief Parse an expression string into an Abstract Syntax Tree
         * @param expression The expression string to parse
         * @return The root AST node
         * @throws ExprException If the expression syntax is invalid
         *
         * This method is primarily for internal use. Most users should use
         * Eval() for direct evaluation or Compile() for cached expressions.
         */
        static ASTNodePtr Parse(const std::string& expression) {
            Parser parser(expression);
            return parser.parse();
        }

        /**
         * @brief Parse an expression string into an Abstract Syntax Tree with token collection
         * @param expression The expression string to parse
         * @param tokens Optional vector to collect tokens for syntax highlighting
         * @return The root AST node
         * @throws ExprException If the expression syntax is invalid
         *
         * This method parses the expression while optionally collecting tokens
         * that can be used for syntax highlighting or other analysis.
         */
        static ASTNodePtr Parse(const std::string& expression, std::vector<Token>* tokens) {
            Parser parser(expression, tokens);
            return parser.parse();
        }

        /**
         * @brief Call standard mathematical functions
         * @param functionName The name of the function to call
         * @param args The arguments to pass to the function
         * @param outResult Reference to store the result
         * @return true if the function was found and executed successfully, false otherwise
         *
         * This function delegates to the standalone CallStandardFunctions for consistency.
         */
        static bool CallStandardFunctions(const std::string& functionName,
                                        const std::vector<Value>& args,
                                        Value& outResult) {
            return ::ExpressionKit::CallStandardFunctions(functionName, args, outResult);
        }
    };

    // Namespace-level convenience functions for backward compatibility and easier usage
    /**
     * @brief Evaluate an expression string directly (namespace-level convenience function)
     */
    inline Value Eval(const std::string& expression, IEnvironment* environment = nullptr) {
        return Expression::Eval(expression, environment);
    }

    /**
     * @brief Evaluate an expression string directly with token collection (namespace-level convenience function)
     */
    inline Value Eval(const std::string& expression, IEnvironment* environment, std::vector<Token>* tokens) {
        return Expression::Eval(expression, environment, tokens);
    }

    /**
     * @brief Parse an expression string into an Abstract Syntax Tree (namespace-level convenience function)
     */
    inline ASTNodePtr Parse(const std::string& expression) {
        return Expression::Parse(expression);
    }

    /**
     * @brief Parse an expression string into an Abstract Syntax Tree with token collection (namespace-level convenience function)
     */
    inline ASTNodePtr Parse(const std::string& expression, std::vector<Token>* tokens) {
        return Expression::Parse(expression, tokens);
    }

} // namespace ExpressionKit

#endif // EXPRESSION_KIT_HPP
